<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>XRBitcoin — V2 (XRPL Read-Only)</title>
  <meta name="theme-color" content="#000428" />
  <meta name="description" content="XRBitcoin (XRPL) — live best price from order books, order book preview, and network status via proxy." />
  <style>
    :root{--gold-1:#ffd700;--gold-2:#fff8dc;--blue-1:#000428;--blue-2:#004e92;--ink:#eaf2ff;--muted:#b8c7e0;--card-bg:rgba(0,0,0,.55);--radius:18px;--gap:16px;--section:80px}
    *{box-sizing:border-box}html,body{height:100%}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica,Arial;color:var(--ink);background:linear-gradient(135deg,var(--blue-1),var(--blue-2))}
    header{padding:24px 16px 8px;text-align:center}
    .brand{display:inline-flex;flex-direction:column;gap:4px;padding:10px 16px;border-radius:18px;background:rgba(255,255,255,.06);box-shadow:0 6px 28px rgba(0,0,0,.25);backdrop-filter:blur(6px)}
    .brand h1{font-size:22px;line-height:1.1;margin:0}.brand p{margin:2px 0 0;font-size:13px;color:var(--muted)}
    main{padding:24px 16px var(--section);max-width:1100px;margin:0 auto;display:grid;grid-template-columns:1fr;gap:var(--gap)}
    @media (min-width:900px){main{grid-template-columns:1.2fr 1fr}}
    .card{background:var(--card-bg);border:1px solid rgba(255,255,255,.12);border-radius:var(--radius);padding:16px;box-shadow:0 12px 40px rgba(0,0,0,.35)}
    .card h2{margin:0 0 12px;font-size:18px;letter-spacing:.2px}.muted{color:var(--muted);font-size:12px}
    .row{display:flex;align-items:center;justify-content:space-between;gap:10px}.big{font-size:32px;font-weight:800;letter-spacing:.5px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    table{width:100%;border-collapse:collapse}th,td{padding:8px 6px;border-bottom:1px dashed rgba(255,255,255,.12);font-size:14px;text-align:right}
    th:first-child,td:first-child{text-align:left}.status{min-height:20px;font-size:13px;color:var(--gold-2)}
  </style>
</head>
<body>
  <header>
    <div class="brand">
      <h1>XRBitcoin</h1>
      <p>XRPL • Live Order Book & Status</p>
    </div>
  </header>

  <!-- Proxy selector -->
  <div style="margin-top:12px; display:flex; justify-content:center; gap:10px; flex-wrap:wrap">
    <label class="muted" for="proxySel" style="align-self:center">Proxy:</label>
    <select id="proxySel" class="mono" style="padding:8px 10px; border-radius:12px; border:1px solid rgba(255,255,255,0.15); background:rgba(255,255,255,0.06); color:#eaf2ff">
      <option value="https://xrbitcoincash-github-io.onrender.com">xrbitcoincash-github-io.onrender.com</option>
      <option value="https://xrbitcoin-github-io.onrender.com">xrbitcoin-github-io.onrender.com</option>
    </select>
    <span class="muted" id="activeProxyNote">(active)</span>
  </div>

  <main>
    <section class="card" id="priceCard">
      <h2>Best Price <span class="muted">(XRBitcoin ↔ XRP)</span></h2>
      <div class="row">
        <div><div class="muted">Best Ask (sell XRBitcoin for XRP)</div><div class="big mono" id="bestAsk">—</div></div>
        <div><div class="muted">Best Bid (buy XRBitcoin with XRP)</div><div class="big mono" id="bestBid">—</div></div>
      </div>
      <div class="muted" style="margin-top:8px">Mid (indicative): <span class="mono" id="midPx">—</span> XRP / XRBitcoin</div>
      <div class="status" id="status1"></div>
    </section>

    <section class="card" id="orderbookCard">
      <h2>Order Book Preview <span class="muted">(Top 10 per side)</span></h2>
      <div class="row" style="gap:18px; align-items:flex-start">
        <div style="flex:1">
          <div class="muted" style="margin-bottom:6px">Asks (price in XRP per XRBitcoin)</div>
          <table id="asksTbl"><thead><tr><th>Price</th><th>Size</th></tr></thead><tbody></tbody></table>
        </div>
        <div style="flex:1">
          <div class="muted" style="margin-bottom:6px">Bids (price in XRP per XRBitcoin)</div>
          <table id="bidsTbl"><thead><tr><th>Price</th><th>Size</th></tr></thead><tbody></tbody></table>
        </div>
      </div>
      <div class="status" id="status2"></div>
    </section>

    <section class="card" id="metaCard">
      <h2>Token • XRBitcoin</h2>
      <div class="mono" style="font-size:13px; line-height:1.5">
        <div><b>Issuer</b>: rGQaHbQHCsTLQtboQPwUBasXjLvk8uDbpT</div>
        <div><b>Currency HEX</b>: 5852626974636F696E0000000000000000000000</div>
        <div><b>Network</b>: XRPL Mainnet</div>
        <div><b>Proxy</b>: (select above)</div>
      </div>
      <div class="status" id="status3" style="margin-top:8px"></div>
    </section>

    <section class="card" id="healthCard">
      <h2>XRPL Health</h2>
      <div class="row"><div class="muted">Last ledger index</div><div class="mono" id="ledgerIndex">—</div></div>
      <div class="row"><div class="muted">Close time (UTC)</div><div class="mono" id="ledgerClose">—</div></div>
      <div class="status" id="status4"></div>
    </section>
  </main>

  <script>
// Default to working Render proxy (persist override in localStorage)
let PROXY = localStorage.getItem('xrbtc_proxy') || 'https://xrbitcoincash-github-io.onrender.com';

const XRBITCOIN = {
  currency: '5852626974636F696E0000000000000000000000',
  issuer:   'rGQaHbQHCsTLQtboQPwUBasXjLvk8uDbpT',
};

// --- utils ---
const $ = (id) => document.getElementById(id);
const fmt = (n) => Number(n).toLocaleString(undefined, { maximumFractionDigits: 8 });
const sleep = (ms) => new Promise(r => setTimeout(r, ms));

function spinner(targetId, msgs) {
  let i = 0; const el = $(targetId);
  el.textContent = msgs[0] || '';
  const iv = setInterval(() => { i = (i + 1) % msgs.length; el.textContent = msgs[i]; }, 1500);
  return () => clearInterval(iv);
}

function renderActiveProxyNote() {
  const el = $('activeProxyNote');
  if (el) el.textContent = `(active: ${new URL(PROXY).host})`;
  const metaProxyLine = Array.from(document.querySelectorAll('#metaCard .mono div'))
    .find(d => d.textContent.trim().startsWith('Proxy'));
  if (metaProxyLine) metaProxyLine.innerHTML = `<b>Proxy</b>: ${PROXY}`;
}

// --- small retry helper for cold starts / transient network errs ---
async function retry(fn, {tries=3, base=300} = {}) {
  let lastErr;
  for (let i = 0; i < tries; i++) {
    try { return await fn(); }
    catch (e) {
      lastErr = e;
      const msg = String(e?.message || e);
      const transient = (
        msg.includes('Network/CORS') ||
        msg.includes('Timeout') ||
        msg.includes('Failed to fetch') ||
        msg.includes('Proxy HTTP 502')
      );
      if (!transient || i === tries - 1) throw lastErr;
      await sleep(base * Math.pow(2, i)); // 300ms, 600ms, 1200ms
    }
  }
  throw lastErr;
}

// Robust RPC with timeout + clearer errors
async function rpc(body) {
  const ctrl = new AbortController();
  const tm = setTimeout(() => ctrl.abort(), 15000);
  try {
    const r = await fetch(PROXY, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
      signal: ctrl.signal,
      mode: 'cors'
    });
    if (!r.ok) {
      const text = await r.text().catch(()=> '');
      throw new Error(`Proxy HTTP ${r.status} ${r.statusText}${text ? ' – ' + text : ''}`);
    }
    const j = await r.json();
    if (j?.result?.status === 'error' || j?.result?.error) throw new Error(`XRPL error: ${j.result.error || j.result.status}`);
    if (j?.error) throw new Error(`XRPL error: ${j.error}`);
    return j;
  } catch (err) {
    if (err?.name === 'AbortError') throw new Error('Timeout talking to proxy/XRPL (15s)');
    if (String(err).includes('Failed to fetch')) throw new Error('Network/CORS: browser could not reach the proxy URL');
    throw err;
  } finally { clearTimeout(tm); }
}

// --- Amount helpers (handle XRP string vs object; IOU object) ---
function amtXRP(a) {
  if (typeof a === 'string') return Number(a) / 1_000_000;      // drops → XRP
  if (a && typeof a === 'object' && a.currency === 'XRP' && a.value != null) return Number(a.value);
  return NaN;
}
function amtIOU(a) {
  if (a && typeof a === 'object' && a.value != null) return Number(a.value);
  return NaN;
}

// Offer helpers (use defensive parsing)
function priceFromOffer(ofr, side) {
  if (side === 'ask') {
    // ask: taker_gets = IOU, taker_pays = XRP
    const xrp = amtXRP(ofr.taker_pays);
    const iou = amtIOU(ofr.taker_gets);
    return (isFinite(xrp) && isFinite(iou) && iou > 0) ? (xrp / iou) : NaN;
  } else {
    // bid: taker_gets = XRP, taker_pays = IOU
    const xrp = amtXRP(ofr.taker_gets);
    const iou = amtIOU(ofr.taker_pays);
    return (isFinite(xrp) && isFinite(iou) && iou > 0) ? (xrp / iou) : NaN;
  }
}
function sizeFromOffer(ofr, side) {
  // display size in XRBitcoin units (IOU amount)
  return side === 'ask' ? amtIOU(ofr.taker_gets) : amtIOU(ofr.taker_pays);
}

// ==== Cascading order-book loader ====
async function loadOrderBooks() {
  const stop1 = spinner('status1', ['Getting validated ledger…','Loading asks…','Loading bids…','Formatting rows…']);
  const stop2 = spinner('status2', ['Preparing tables…','Almost there…']);

  try {
    // 1) one validated ledger to keep snapshot consistent (with retry)
    const { result: led } = await retry(() =>
      rpc({ method: 'ledger', params: [{ ledger_index: 'validated' }] })
    );
    const lidx = led.ledger_index;

    await sleep(150);

    // 2) asks: sell XRBitcoin -> get XRP (with retry)
    const asksResp = await retry(() =>
      rpc({
        method: 'book_offers',
        params: [{
          ledger_index: lidx,
          taker_gets: { currency: XRBITCOIN.currency, issuer: XRBITCOIN.issuer },
          taker_pays: { currency: 'XRP' },
          limit: 25
        }]
      })
    );

    await sleep(150);

    // 3) bids: buy XRBitcoin -> pay XRP (with retry)
    const bidsResp = await retry(() =>
      rpc({
        method: 'book_offers',
        params: [{
          ledger_index: lidx,
          taker_gets: { currency: 'XRP' },
          taker_pays: { currency: XRBITCOIN.currency, issuer: XRBITCOIN.issuer },
          limit: 25
        }]
      })
    );

    // 4) render (filter out malformed lines)
    const asksRes = asksResp.result || {};
    const bidsRes = bidsResp.result || {};

    const asks = (asksRes.offers || [])
      .map(o => ({ px: priceFromOffer(o, 'ask'), sz: sizeFromOffer(o, 'ask') }))
      .filter(r => Number.isFinite(r.px) && Number.isFinite(r.sz))
      .sort((a,b) => a.px - b.px);

    const bids = (bidsRes.offers || [])
      .map(o => ({ px: priceFromOffer(o, 'bid'), sz: sizeFromOffer(o, 'bid') }))
      .filter(r => Number.isFinite(r.px) && Number.isFinite(r.sz))
      .sort((a,b) => b.px - a.px);

    const bestAsk = asks[0]?.px;
    const bestBid = bids[0]?.px;

    $('bestAsk').textContent = bestAsk ? fmt(bestAsk) : '—';
    $('bestBid').textContent = bestBid ? fmt(bestBid) : '—';
    const mid = (bestAsk && bestBid) ? (bestAsk + bestBid) / 2 : null;
    $('midPx').textContent = mid ? fmt(mid) : '—';

    const asksBody = $('asksTbl').querySelector('tbody');
    const bidsBody = $('bidsTbl').querySelector('tbody');
    asksBody.innerHTML = ''; bidsBody.innerHTML = '';

    asks.slice(0,10).forEach(r => {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td class="mono">${fmt(r.px)}</td><td class="mono">${fmt(r.sz)}</td>`;
      asksBody.appendChild(tr);
    });
    bids.slice(0,10).forEach(r => {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td class="mono">${fmt(r.px)}</td><td class="mono">${fmt(r.sz)}</td>`;
      bidsBody.appendChild(tr);
    });

    stop1(); stop2();
    $('status1').textContent = 'Live from XRPL order books.';
    $('status2').textContent = `Asks: ${asks.length} • Bids: ${bids.length}`;
  } catch (e) {
    stop1(); stop2();
    $('status1').textContent = 'Error loading price.';
    $('status2').textContent = String(e.message || e);
  }
}

async function loadHealth() {
  const stop = spinner('status4', ['Pinging ledger…','Reading close time…','Verifying response…']);
  try {
    const { result } = await retry(() =>
      rpc({ method: 'ledger', params: [{ ledger_index: 'validated' }] })
    );
    $('ledgerIndex').textContent = result.ledger_index ?? '—';
    const ct = result.ledger?.close_time_human || result.closed?.ledger_time || '';
    $('ledgerClose').textContent = ct || '—';
    stop();
    $('status4').textContent = 'XRPL is responding.';
  } catch (e) {
    stop();
    $('status4').textContent = 'Health check failed: ' + (e.message || e);
  }
}

function initProxySelector(){
  const sel = document.getElementById('proxySel');
  if (!sel) return;
  for (let i=0;i<sel.options.length;i++) {
    if (sel.options[i].value === PROXY) { sel.selectedIndex = i; break; }
  }
  sel.addEventListener('change', () => {
    PROXY = sel.value;
    localStorage.setItem('xrbtc_proxy', PROXY);
    renderActiveProxyNote();
    loadOrderBooks();
    loadHealth();
  });
  renderActiveProxyNote();
}

function boot() {
  initProxySelector();
  loadOrderBooks();
  loadHealth();
  setInterval(loadOrderBooks, 20000);
  setInterval(loadHealth, 60000);
}
addEventListener('DOMContentLoaded', boot);


  </script>
</body>
</html>
